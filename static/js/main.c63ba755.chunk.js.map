{"version":3,"sources":["components/TddNotebook.js","App.js","serviceWorker.js","index.js"],"names":["code","TddNotebook","className","style","fontFamily","textAlign","text","language","showLineNumbers","theme","monoBlue","wrapline","App","path","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"oQA8BA,IAAIA,EAAI,g+HAkFOC,EA7Gf,WACI,OACI,yBAAKC,UAAU,aACX,iEACA,maACA,igBACA,yFACA,mFACA,kJACA,4BACI,wRACA,kKACA,8MAEJ,yBAAKC,MAAO,CAAEC,WAAY,YAAaC,UAAW,SAC9C,kBAAC,IAAD,CACIC,KAAMN,EACNO,SAAU,OACVC,iBAAiB,EACjBC,MAAOC,IACPC,UAAQ,O,MCQbC,MAlBf,WACE,OACI,kBAAC,IAAD,KACA,6BACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAOC,KAAK,iBACV,kBAAC,EAAD,OAEF,kBAAC,IAAD,CAAOA,KAAK,KACV,kBAAC,EAAD,WCVQC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCXNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDwHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.c63ba755.chunk.js","sourcesContent":["import React from 'react';\r\nimport { CopyBlock, monoBlue } from \"react-code-blocks\";\r\n\r\nfunction TddNotebook() {\r\n    return (\r\n        <div className=\"container\">\r\n            <h2>Test driven development textbook </h2>\r\n            <p>Test driven development is not new but as technology is progressing there has been a change in software development process and TDD has gain popularity and embraced by Companies at large. Few factors which have effected this change are ease of integrating dynamically changing requirements, bug fix and application changes are quick and finally my favorite low tech-depth with clean code.</p>\r\n            <p>For many years I too tried to understand this new power just by thinking and trying to answer how... how to write a test before the code and felt clueless. Only recently I have the time and people to help me move in this direction. I have documented a small POC project that might help few developers in this learning process. Also, might help few to understand, with little time and effort test driven development possible for every piece of code. Hope this will be helpful to few.</p>\r\n            <blockquote>Developer super power => Red -> Green -> Refactor</blockquote>\r\n            <blockquote>Think first=> Assemble -- Act â€“ Assert</blockquote>\r\n            <h3>Important points I like to share which will be reflected in my code below which can help in strong TDD foundation:</h3>\r\n            <ul>\r\n                <li>Whenever using mock try passing the actual expected values instead of using matchers like (any,  anyString, anyList, etc) unless you have a string reason to do so, as passing actual data to mock method is a kind of code verification/code assertion.</li>\r\n                <li>Always verify your test case hypotheses by checking everything like assertions, method call verification, exceptions verification.</li>\r\n                <li>Once green try to change code and make your test case fail for every scenario it's expected to fail that will help in deeper understanding and strong test case verification.</li>\r\n            </ul>\r\n            <div style={{ fontFamily: 'Fira Code', textAlign: 'left' }}>\r\n                <CopyBlock\r\n                    text={code}\r\n                    language={'java'}\r\n                    showLineNumbers={false}\r\n                    theme={monoBlue}\r\n                    wrapline\r\n                />\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nlet code = `\r\n\r\n\r\n/*Creating mock bean with a mock method call for testing init/lifecycle methods  */\r\n@ExtendWith(SpringExtension.class)\r\n@ContextConfiguration(classes = {PublishMsgTokenApiImplTest.MockBeanConfiguration.class})\r\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\r\npublic class PublishMsgTokenApiImplTest implements CommDataSet {\r\n    @Configuration\r\n    public static class MockBeanConfiguration implements CommDataSet {\r\n        @Autowired\r\n        private PublishApiConfig publishApiConfig;\r\n\r\n        @Bean\r\n        public RestTemplate createRestTemplate() {\r\n            RestTemplate restTemplate = mock(RestTemplate.class);\r\n            HttpEntity<TokenRequest> entity = getTokenRequestHttpEntity(publishApiConfig);\r\n            ResponseEntity<TokenResponse> responseEntity = getTokenResponseResponseEntity();\r\n            when(restTemplate.exchange(eq(publishApiConfig.getTokenUrl()), eq(HttpMethod.POST), eq(entity), eq(TokenResponse.class)))\r\n                    .thenReturn(responseEntity);\r\n            return restTemplate;\r\n        }\r\n\r\n    }\r\n\r\n    @Test\r\n    @Order(1)\r\n    void test_init_method_loadToken() {\r\n        verify(restTemplate, times(1))\r\n                .exchange(eq(publishApiConfig.getTokenUrl()), eq(HttpMethod.POST), any(), eq(TokenResponse.class));\r\n    }\r\n\r\n    /*Executing same mock method multiple time on a same test with different responses like Expetions Generic method the code is in the rest template mocking also for retry*/\r\n    @Test\r\n    void test_update_method_Success_With_Retry() {\r\n        //Assemble\r\n        HttpEntity<TokenRequest> entity = getTokenRequestHttpEntity(publishApiConfig);\r\n        TokenResponse tokenRequestNew = new TokenResponse(\"new-access-token-retry\", TOKEN_TYPE, EXPIRES_IN);\r\n        ResponseEntity<TokenResponse> responseEntity = new ResponseEntity<>(tokenRequestNew, HttpStatus.OK);\r\n        when(restTemplate.exchange(eq(publishApiConfig.getTokenUrl()), eq(HttpMethod.POST), eq(entity), eq(TokenResponse.class)))\r\n                .thenAnswer(invocationOnMock -> {\r\n                    if (INNVOCATION_COUNT == 0 || INNVOCATION_COUNT == 1) {\r\n                        INNVOCATION_COUNT++;\r\n                        HttpHeaders headers = new HttpHeaders();\r\n                        throw new RestClientResponseException(\"Rest exp\", 403, \"Forbidden\", headers, null, null);\r\n                    }\r\n                    return responseEntity;\r\n                });\r\n        //ACT\r\n        publishMsgTokenApi.updateToken();\r\n        //Assert\r\n        assertEquals(\"new-access-token-retry\", publishMsgTokenApi.getAccessToken());\r\n        verify(restTemplate, times(3))\r\n                .exchange(eq(publishApiConfig.getTokenUrl()), eq(HttpMethod.POST), any(), eq(TokenResponse.class));\r\n    }\r\n\r\n    //Verify everything not just exception to prove you test hypothies is correct.\r\n    @Test\r\n    void test_publishMessage_return_401Unauthorized_UpdateToken_PublishMsg_re_return_401_Failure() {\r\n        //Assemble\r\n        HttpEntity<DisplayMsgRequest> entity = new HttpEntity<>(getDisplayMsgRequest(), getHttpHeadersPublishMsgApi());\r\n\r\n        when(restTemplate.exchange(eq(publishApiConfig.getPublishApiUrl()), eq(HttpMethod.POST), eq(entity), eq(DisplayMessage.class)))\r\n                .thenThrow(new RestClientResponseException(UNAUTHORIZED_MSG, UNAUTHORIZED_STATUS_CODE, UNAUTHORIZED_STATUS_TXT, getUnauthorizedHeader(), null, null));\r\n        //Act\r\n        RestClientResponseException response = assertThrows(RestClientResponseException.class,\r\n                () -> publishMsgApiService.publishNewMsg(getDisplayMsgRequest()));\r\n        //Assert\r\n        assertEquals(UNAUTHORIZED_STATUS_CODE, response.getRawStatusCode());\r\n        verify(restTemplate, times(2))\r\n                .exchange(eq(publishApiConfig.getPublishApiUrl()),\r\n                        eq(HttpMethod.POST),\r\n                        eq(entity), eq(DisplayMessage.class));\r\n        verify(publishMsgTokenApi, times(2)).getAccessToken();\r\n        verify(publishMsgTokenApi, times(1)).updateToken();\r\n    }\r\n}\r\n\r\n\r\n`;\r\n\r\n\r\nexport default TddNotebook;","import React from 'react';\r\nimport {\r\n  BrowserRouter as Router,\r\n  Switch,\r\n  Route,\r\n  Link,\r\n  useRouteMatch,\r\n  useParams\r\n} from \"react-router-dom\";\r\nimport TddNotebook from './components/TddNotebook';\r\nimport './App.css';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n      <Router>\r\n      <div>\r\n        <Switch>\r\n          <Route path=\"/tdd-notebook\">\r\n            <TddNotebook />\r\n          </Route>\r\n          <Route path=\"/\">\r\n            <TddNotebook />\r\n          </Route>\r\n        </Switch>\r\n      </div>\r\n    </Router>\r\n     \r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}